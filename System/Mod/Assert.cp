MODULE Assert;
(*
	History:
	Date:	Author:	Change:
	13-Apr-2008	Rainer Neubauer	expanded version: for BlackBox
	.		collapsed version: for BlackBox plus LabView run time system
	30-Apr-2008	Rainer Neubauer	folds for switching between source code versions replaced by selectors
	05-Nov-2008	Rainer Neubauer	added: PreIntParInHexRange
			Module StdLog replaced by Stderr
	30-Oct-2009 Rainer Neubauer		WriteLabviewStackAndTimeLn replaced by WriteTimeLn
*)

	IMPORT Stderr, Strings;

	CONST
		(* error codes according to black box programming conventions *)
		minErrorPre	 = 20;
		maxErrorPre	 = 59;
		minErrorPost	 = 60;
		maxErrorPost	 = 99;
		minErrorInvariant	 = 100;
		maxErrorInvariant	 = 120;
		invariantInernalLabViewError	 = 121; (* Reserved for errors generated by LabView code *)
		errorNotYetImplemented	 = 126;

		preAnyCondition	 = minErrorPre + 0;
		preIntParNegative	 = minErrorPre + 1;
		preIntParNotNegative	 = minErrorPre + 2;
		preIntParNotZero	 = minErrorPre + 3;
		preIntParPositive	 = minErrorPre + 4;
		preIntParBelowUpperLim	 = minErrorPre + 5;
		preIntParAboveLowerLim	 = minErrorPre + 6;
		preIntParInRange	 = minErrorPre + 7;
		preIntParEqual	 = minErrorPre + 8;
		preIntParNotEqual	 = minErrorPre + 9;

		preRealParNegative	 = minErrorPre + 10;
		preRealParNotNegative	 = minErrorPre + 11;
		preRealParNotZero	 = minErrorPre + 12;
		preRealParPositive	 = minErrorPre + 13;
		preRealParBelowUpperLim	 = minErrorPre + 14;
		preRealParAboveLowerLim	 = minErrorPre + 15;
		preRealParInRange	 = minErrorPre + 16;

		preIntParInHexRange	 = minErrorPre + 17;

		preStringValid	 = minErrorPre + 20;
		preStringNotEmpty	 = minErrorPre + 22;
		preStringNotTooLong	 = minErrorPre + 23;
		preStringLenIs1	 = minErrorPre + 24; (* Reserverd for LabView which has no data type CHAR *)
		preStringLenOk	 = minErrorPre + 25;

		preModuleNotInit	 = minErrorPre + 34;
		preMonitorExists	 = minErrorPre + 35;
		preMonitorIsNotLinked	 = minErrorPre + 36;
		preMonitorIsLinked	 = minErrorPre + 37;
		preModuleInit	 = minErrorPre + 38;
		prePtrNotNil	 = minErrorPre + 39;


		postAnyCondition	 = minErrorPost + 0;
		postIntParInRange	 = minErrorPost + 7;
		postIntParEqual	 = minErrorPost + 8;
		postIntParNotEqual	 = minErrorPost + 9;

		postStringValid	 = minErrorPost + 20;
		postStringEmpty	 = minErrorPost + 21;
		postStringNotEmpty	 = minErrorPost + 22;
		postStringNotTooLong	 = minErrorPost + 23;
		postStringLenOk	 = minErrorPost + 25;
		postStringsEqual	 = minErrorPost + 26;

		invariantAnyCondition	 = minErrorInvariant + 0;


	PROCEDURE WriteConditionViolated (inErrorCode: INTEGER);
	BEGIN
		CASE inErrorCode OF
		| minErrorPre .. maxErrorPre:
			Stderr.String ("Preconditon violated."); Stderr.Ln
		| minErrorPost .. maxErrorPost:
			Stderr.String ("Postconditon violated."); Stderr.Ln
		| minErrorInvariant .. maxErrorInvariant:
			Stderr.String ("Module invariant violated."); Stderr.Ln
		| invariantInernalLabViewError:
			Stderr.String ("LabView error cluster is not empty."); Stderr.Ln
		ELSE
			Stderr.String ("This error code not yet classified: "); Stderr.Int (inErrorCode); Stderr.Ln
		END
	END WriteConditionViolated;


	PROCEDURE WriteIntPar (IN parName: ARRAY OF CHAR; inParVal: INTEGER);
	BEGIN
		Stderr.String (parName);
		Stderr.String ("  (value: "); Stderr.Int (inParVal); Stderr.String (")")
	END WriteIntPar;

	PROCEDURE WriteHexPar (IN parName: ARRAY OF CHAR; inParVal: INTEGER);
		VAR string: ARRAY 17 OF CHAR; (* 64 bit *)
	BEGIN
		Strings.IntToStringForm (inParVal, Strings.hexadecimal, 1, ' ', TRUE, string);
		Stderr.String (parName + "  (value: " + string + ")")
	END WriteHexPar;

	PROCEDURE WriteRealPar (IN parName: ARRAY OF CHAR; inParVal: REAL);
	BEGIN
		Stderr.String (parName);
		Stderr.String ("  (value: "); Stderr.Real (inParVal); Stderr.String (")")
	END WriteRealPar;


	PROCEDURE WriteStringPar (IN parName: ARRAY OF CHAR; IN string: ARRAY OF CHAR);
	BEGIN
		Stderr.String (parName);
		Stderr.String ('  (value: "'); Stderr.String (string); Stderr.String ('")')
	END WriteStringPar;




	PROCEDURE WriteStringResult (IN string: ARRAY OF CHAR);
	BEGIN
		Stderr.String ('Result string "' + string + '"')
	END WriteStringResult;


	PROCEDURE WriteIntData (x: BOOLEAN; inErrorCode: INTEGER; IN parName: ARRAY OF CHAR; inParVal, inLowerLim, inUpperLim: INTEGER);
		VAR lowerLimString, upperLimString: ARRAY 17 OF CHAR; (* 64 bit *)
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (inErrorCode);

			CASE inErrorCode OF
			| preIntParNegative:
				WriteIntPar (parName, inParVal); Stderr.String (" must be negative.")
			| preIntParNotNegative:
				WriteIntPar (parName, inParVal); Stderr.String (" must not be negative.")
			| preIntParNotZero:
				WriteIntPar (parName, inParVal); Stderr.String (" must not be 0.")
			| preIntParPositive:
				WriteIntPar (parName, inParVal); Stderr.String (" must be greater 0.")
			| preIntParBelowUpperLim:
				WriteIntPar (parName, inParVal); Stderr.String (" must be < "); Stderr.Int (inUpperLim)
			| preIntParAboveLowerLim:
				WriteIntPar (parName, inParVal); Stderr.String (" must be > "); Stderr.Int (inLowerLim)
			| preIntParInRange, postIntParInRange:
				WriteIntPar (parName, inParVal); Stderr.String (" must be in range: "); Stderr.Int (inLowerLim); Stderr.String (" ... "); Stderr.Int (inUpperLim)
			| preIntParInHexRange:
				Strings.IntToStringForm (inLowerLim, Strings.hexadecimal, 1, ' ', TRUE, lowerLimString);
				Strings.IntToStringForm (inUpperLim, Strings.hexadecimal, 1, ' ', TRUE, upperLimString);
				WriteHexPar (parName, inParVal); Stderr.String (" must be in range: " + lowerLimString + " ... " + upperLimString)
			| preIntParEqual, postIntParEqual:
				WriteIntPar (parName, inParVal); Stderr.String (" must be equal to "); Stderr.Int (inLowerLim)
			| preIntParNotEqual, postIntParNotEqual:
				WriteIntPar (parName, inParVal); Stderr.String (" must not be equal to "); Stderr.Int (inLowerLim)
			ELSE
				Stderr.String ("No condition defined for error code: "); Stderr.Int (inErrorCode)
			END;
			Stderr.Ln
		END
	END WriteIntData;



	PROCEDURE WriteRealData (x: BOOLEAN; inErrorCode: INTEGER; IN parName: ARRAY OF CHAR; inParVal, inLowerLim, inUpperLim: REAL);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (inErrorCode);

			CASE inErrorCode OF
			| preRealParNegative:
				WriteRealPar (parName, inParVal); Stderr.String (" must be negative.")
			| preRealParNotNegative:
				WriteRealPar (parName, inParVal); Stderr.String (" must not be negative.")
			| preRealParNotZero:
				WriteRealPar (parName, inParVal); Stderr.String (" must not be 0.")
			| preRealParPositive:
				WriteRealPar (parName, inParVal); Stderr.String (" must be greater 0.")
			| preRealParBelowUpperLim:
				WriteRealPar (parName, inParVal); Stderr.String (" must be < "); Stderr.Real (inUpperLim)
			| preRealParAboveLowerLim:
				WriteRealPar (parName, inParVal); Stderr.String (" must be > "); Stderr.Real (inLowerLim)
			| preRealParInRange:
				WriteRealPar (parName, inParVal); Stderr.String (" must be in range: "); Stderr.Real (inLowerLim); Stderr.String (" ... "); Stderr.Real (inUpperLim)
			ELSE
				Stderr.String ("No condition defined for error code: "); Stderr.Int (inErrorCode)
			END;
			Stderr.Ln
		END
	END WriteRealData;


	PROCEDURE WriteTimeLn (x: BOOLEAN);
	BEGIN
		IF ~ x THEN
			Stderr.TimeLn 
		END
	END WriteTimeLn;



	(* ==================================== Preconditions ================================= *)
	(* ================================================================================= *)

	PROCEDURE PreAnyCondition* (x: BOOLEAN; IN condition: ARRAY OF CHAR);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (preAnyCondition);
			Stderr.String (condition); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, preAnyCondition)
		END
	END PreAnyCondition;



	(* =============================== Preconditions INTEGER parameter ========================== *)

	PROCEDURE PreIntParNegative* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal: INTEGER);
	BEGIN
		WriteIntData (x, preIntParNegative, parName, inParVal, 0, 0);
		WriteTimeLn (x);
		ASSERT (x, preIntParNegative)
	END PreIntParNegative;


	PROCEDURE PreIntParNotNegative* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal: INTEGER);
	BEGIN
		WriteIntData (x, preIntParNotNegative, parName, inParVal, 0, 0);
		WriteTimeLn (x);
		ASSERT (x, preIntParNotNegative)
	END PreIntParNotNegative;


	PROCEDURE PreIntParNotZero* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal: INTEGER);
	BEGIN
		WriteIntData (x, preIntParNotZero, parName, inParVal, 0, 0);
		WriteTimeLn (x);
		ASSERT (x, preIntParNotZero)
	END PreIntParNotZero;


	PROCEDURE PreIntParPositive* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal: INTEGER);
	BEGIN
		WriteIntData (x, preIntParPositive, parName, inParVal, 0, 0);
		WriteTimeLn (x);
		ASSERT (x, preIntParPositive)
	END PreIntParPositive;


	PROCEDURE PreIntParBelowUpperLim* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inUpperLim: INTEGER);
	BEGIN
		WriteIntData (x, preIntParBelowUpperLim, parName, inParVal, 0, inUpperLim);
		WriteTimeLn (x);
		ASSERT (x, preIntParBelowUpperLim)
	END PreIntParBelowUpperLim;


	PROCEDURE PreIntParAboveLowerLim* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inLowerLim: INTEGER);
	BEGIN
		WriteIntData (x, preIntParAboveLowerLim, parName, inParVal, inLowerLim, 0);
		WriteTimeLn (x);
		ASSERT (x, preIntParAboveLowerLim)
	END PreIntParAboveLowerLim;


	PROCEDURE PreIntParInRange* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inLowerLim, inUpperLim: INTEGER);
	BEGIN
		WriteIntData (x, preIntParInRange, parName, inParVal, inLowerLim, inUpperLim);
		WriteTimeLn (x);
		ASSERT (x, preIntParInRange)
	END PreIntParInRange;


	PROCEDURE PreIntParInHexRange* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inLowerLim, inUpperLim: INTEGER);
	BEGIN
		WriteIntData (x, preIntParInHexRange, parName, inParVal, inLowerLim, inUpperLim);
		WriteTimeLn (x);
		ASSERT (x, preIntParInRange)
	END PreIntParInHexRange;


	PROCEDURE PreIntParEqual* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inTargetVal: INTEGER);
	BEGIN
		WriteIntData (x, preIntParEqual, parName, inParVal, inTargetVal, 0);
		WriteTimeLn (x);
		ASSERT (x, preIntParEqual)
	END PreIntParEqual;


	PROCEDURE PreIntParNotEqual* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inTargetVal: INTEGER);
	BEGIN
		WriteIntData (x, preIntParNotEqual, parName, inParVal, inTargetVal, 0);
		WriteTimeLn (x);
		ASSERT (x, preIntParNotEqual)
	END PreIntParNotEqual;




	(* =============================== Preconditions REAL parameter ========================== *)

	PROCEDURE PreRealParNegative* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal: REAL);
	BEGIN
		WriteRealData (x, preRealParNegative, parName, inParVal, 0, 0);
		WriteTimeLn (x);
		ASSERT (x, preRealParNegative)
	END PreRealParNegative;


	PROCEDURE PreRealParNotNegative* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal: REAL);
	BEGIN
		WriteRealData (x, preRealParNotNegative, parName, inParVal, 0, 0);
		WriteTimeLn (x);
		ASSERT (x, preRealParNotNegative)
	END PreRealParNotNegative;


	PROCEDURE PreRealParNotZero* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal: REAL);
	BEGIN
		WriteRealData (x, preRealParNotZero, parName, inParVal, 0, 0);
		WriteTimeLn (x);
		ASSERT (x, preRealParNotZero)
	END PreRealParNotZero;


	PROCEDURE PreRealParPositive* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal: REAL);
	BEGIN
		WriteRealData (x, preRealParPositive, parName, inParVal, 0, 0);
		WriteTimeLn (x);
		ASSERT (x, preRealParPositive)
	END PreRealParPositive;


	PROCEDURE PreRealParBelowUpperLim* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inUpperLim: REAL);
	BEGIN
		WriteRealData (x, preRealParBelowUpperLim, parName, inParVal, 0, inUpperLim);
		WriteTimeLn (x);
		ASSERT (x, preRealParBelowUpperLim)
	END PreRealParBelowUpperLim;


	PROCEDURE PreRealParAboveLowerLim* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inLowerLim: REAL);
	BEGIN
		WriteRealData (x, preRealParAboveLowerLim, parName, inParVal, 0, inLowerLim);
		WriteTimeLn (x);
		ASSERT (x, preRealParAboveLowerLim)
	END PreRealParAboveLowerLim;


	PROCEDURE PreRealParInRange* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inLowerLim, inUpperLim: REAL);
	BEGIN
		WriteRealData (x, preRealParInRange, parName, inParVal, inLowerLim, inUpperLim);
		WriteTimeLn (x);
		ASSERT (x, preRealParInRange)
	END PreRealParInRange;




	(* =============================== Preconditions module ========================== *)
	PROCEDURE PreModuleInit* (x: BOOLEAN);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (preModuleInit);
			Stderr.String ("The module must be initialized."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, preModuleInit)
		END
	END PreModuleInit;

	PROCEDURE PreModuleNotInit* (x: BOOLEAN);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (preModuleNotInit);
			Stderr.String ("The module must not be initialized for this call."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, preModuleNotInit)
		END
	END PreModuleNotInit;


	(* =============================== Preconditions pointer parameter ========================== *)
	PROCEDURE PreParNotNil* (x: BOOLEAN; IN parName: ARRAY OF CHAR);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (prePtrNotNil);
			Stderr.String (parName);
			Stderr.String (" must not be NIL"); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, prePtrNotNil)
		END
	END PreParNotNil;


	(* =============================== Preconditions monitor ========================== *)
	PROCEDURE PreMonitorExists* (x: BOOLEAN; IN name: ARRAY OF CHAR);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (preMonitorExists);
			Stderr.String ("The monitor '" + name + "' must exist."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, preMonitorExists)
		END
	END PreMonitorExists;


	PROCEDURE PreMonitorIsLinked* (x: BOOLEAN; IN name: ARRAY OF CHAR);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (preMonitorIsLinked);
			Stderr.String ("The monitor '" + name + "' must be linked."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, preMonitorIsLinked)
		END
	END PreMonitorIsLinked;


	PROCEDURE PreMonitorIsNotLinked* (x: BOOLEAN; IN name: ARRAY OF CHAR);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (preMonitorIsNotLinked);
			Stderr.String ("The monitor '" + name + "' must not be linked."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, preMonitorIsNotLinked)
		END
	END PreMonitorIsNotLinked;


	(* =============================== Preconditions string parameter ========================== *)


	PROCEDURE PreStringValid* (IN parName, parVal: ARRAY OF CHAR);
		VAR x: BOOLEAN;
			i, len: INTEGER;
			str: POINTER TO ARRAY OF CHAR;
	BEGIN
		
		x := Strings.Valid (parVal);
		IF ~ x THEN
			len := LEN (parName);
			NEW (str, len + 1);
			FOR i := 0 TO LEN (parName) - 1 DO
				str^[i] := parName[i]
			END;
			str^[len] := 0X;

			WriteConditionViolated (preStringValid);

			Stderr.String (parName);
			Stderr.String ('  (Value: "' + str + '") ' + " must be terminated by zero-byte."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, preStringValid)
		END
		
	END PreStringValid;


	PROCEDURE PreStringNotEmpty* (x: BOOLEAN; IN parName: ARRAY OF CHAR);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (preStringNotEmpty);
			Stderr.String (parName); Stderr.String (" must not be empty string."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, preStringNotEmpty)
		END
	END PreStringNotEmpty;


	PROCEDURE PreStringLenOk* (x: BOOLEAN; IN parName, parVal: ARRAY OF CHAR; inLen: INTEGER);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (preStringLenOk);
			WriteStringPar (parName, parVal); Stderr.String (": length must be "); Stderr.Int (inLen); Stderr.String (" chars."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, preStringLenOk)
		END
	END PreStringLenOk;


	PROCEDURE PreStringNotTooLong* (x: BOOLEAN; IN parName, parVal: ARRAY OF CHAR; inMaxLen: INTEGER);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (preStringNotTooLong);
			WriteStringPar (parName, parVal); Stderr.String (" must not be longer than "); Stderr.Int (inMaxLen); Stderr.String (" chars."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, preStringNotTooLong)
		END
	END PreStringNotTooLong;




	(* ==================================== Postconditions ================================= *)
	(* ================================================================================= *)

	PROCEDURE PostAnyCondition* (x: BOOLEAN; IN condition: ARRAY OF CHAR);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (postAnyCondition);
			Stderr.String (condition); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, postAnyCondition)
		END
	END PostAnyCondition;



	(* =============================== Postconditions result value ========================== *)

	PROCEDURE PostIntParInRange* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inLowerLim, inUpperLim: INTEGER);
	BEGIN
		WriteIntData (x, postIntParInRange, parName, inParVal, inLowerLim, inUpperLim);
		WriteTimeLn (x);
		ASSERT (x, preIntParInRange)
	END PostIntParInRange;


	PROCEDURE PostIntParEqual* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inTargetVal: INTEGER);
	BEGIN
		WriteIntData (x, postIntParEqual, parName, inParVal, inTargetVal, 0);
		WriteTimeLn (x);
		ASSERT (x, postIntParEqual)
	END PostIntParEqual;


	PROCEDURE PostIntParNotEqual* (x: BOOLEAN; IN parName: ARRAY OF CHAR; inParVal, inTargetVal: INTEGER);
	BEGIN
		WriteIntData (x, postIntParNotEqual, parName, inParVal, inTargetVal, 0);
		WriteTimeLn (x);
		ASSERT (x, postIntParNotEqual)
	END PostIntParNotEqual;


	(* =============================== Postconditions string parameter ========================== *)


	PROCEDURE PostStringValid* (IN string: ARRAY OF CHAR);
		VAR x: BOOLEAN;
			i, len: INTEGER;
			str: POINTER TO ARRAY OF CHAR;
	BEGIN
		
		x := Strings.Valid (string);
		IF ~ x THEN
			len := LEN (string);
			NEW (str, len + 1);
			FOR i := 0 TO LEN (string) - 1 DO
				str^[i] := string[i]
			END;
			str^[len] := 0X;

			WriteConditionViolated (postStringValid);
			Stderr.String ('Result string "' + str + '" must be terminated by zero-byte.'); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, postStringValid)
		END
		
	END PostStringValid;


	PROCEDURE PostStringEmpty* (x: BOOLEAN; IN string: ARRAY OF CHAR);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (postStringEmpty);
			WriteStringResult (string); Stderr.String (" must be empty string."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, postStringEmpty)
		END
	END PostStringEmpty;


	PROCEDURE PostStringNotEmpty* (x: BOOLEAN; IN string: ARRAY OF CHAR);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (postStringNotEmpty);
			WriteStringResult (string); Stderr.String (" must not be empty string."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, postStringNotEmpty)
		END
	END PostStringNotEmpty;


	PROCEDURE PostStringNotTooLong* (x: BOOLEAN; IN parName, parVal: ARRAY OF CHAR; inMaxLen: INTEGER);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (postStringNotTooLong);
			WriteStringPar (parName, parVal); Stderr.String (" must not be longer than "); Stderr.Int (inMaxLen); Stderr.String (" chars."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, postStringNotTooLong)
		END
	END PostStringNotTooLong;


	PROCEDURE PostStringLenOk* (x: BOOLEAN; IN string: ARRAY OF CHAR; inLen: INTEGER);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (postStringLenOk);
			WriteStringResult (string); Stderr.String (": length must be "); Stderr.Int (inLen); Stderr.String (" chars."); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, postStringLenOk)
		END
	END PostStringLenOk;


	PROCEDURE PostStringsEqual* (x: BOOLEAN; IN string1, string2: ARRAY OF CHAR);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (postStringsEqual);
			WriteStringResult (string1$); Stderr.String (' must be equal to "'); Stderr.String (string2$); Stderr.String ('".'); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, postStringsEqual)
		END
	END PostStringsEqual;




	(* ==================================== Invariants ==================================== *)
	(* ================================================================================= *)

	PROCEDURE InvariantAnyCondition* (x: BOOLEAN; IN condition: ARRAY OF CHAR);
	BEGIN
		IF ~ x THEN
			WriteConditionViolated (invariantAnyCondition);
			Stderr.String (condition); Stderr.Ln;
			WriteTimeLn (x); 
			ASSERT (x, invariantAnyCondition)
		END
	END InvariantAnyCondition;
END Assert.
